# 思路整理

## 前言

这个项目在最初的考虑是一个纯前端的项目，其最大的考量是，我当时只有前端的知识，无法构建为前后端结合的项目。

经过一段时间的使用之后，我发现其需要一个服务端的部分，出于以下问题：

1. 待办事项模块中“通知”功能的缺失
   尽管已经有了页面内的到期提示，但是实际上我会有很少的时间会停留在这个页面上，更不用说不在电脑前的时候了。

2. 受限的使用场景
   由于这是个纯前端的项目，现在唯一使用它的方式是，在本地使用vite部署，然后进入localhost。而也许我会希望能在手机上使用它，毕竟我不会一直在电脑前。

3. 仅存储于端的数据
   由于项目是纯前端的，如果我在不同的电脑打开，数据，待办事项、博客文件，不会同步，这是非常不方便的。

考虑到以上问题，为这个项目配置一个服务端目前看来是非常必要的。并且如此解决以上的问题：

1. 在服务端进行配置，将即将到期的待办事项推送到个人联系方式：邮件或短信。
2. 将项目部署到一个服务器上，如个人电脑或租借服务器上。
3. 考虑是否要设计登陆部分（目前看来，可能开发时间不会太长，暂缓设计登陆部分，在完成初步开发后考虑）。
   这里可能会涉及到对于数据的处理。因为本来数据是通过持久化存在浏览器，现在肯定是不需要的，取而代之的是存储在服务端的数据库中。

## 技术选型

由于我是前端开发，所以考虑nodejs方向的框架来搭建服务端。除此之外，还需要选择一个数据库。

### 服务端框架

**Next.js**：

1. **本质上是 React 的增强框架**：在 React 的基础上，提供了开箱即用的解决方案：
   - **服务端渲染 (SSR)**：`getServerSideProps`
   - **静态站点生成 (SSG)**：`getStaticProps`
   - **增量静态再生 (ISR)**：`revalidate` 选项
   - **按需增量静态生成 (On-demand ISR)**：`res.revalidate()`
2. **文件系统即路由**：`pages` 或 `app` 目录下的文件结构自动映射为 URL 路由
3. **API Routes**：在 `pages/api` 或 `app/api` 中创建文件即可编写 Node.js API 端点
4. **前端优化**：自动代码分割、图片优化、字体优化、脚本策略
5. **部署友好**：Vercel 提供极致优化部署体验

**何时选择 Next.js？**

- 需要改善 React 应用的 SEO 和性能
- 需要服务端渲染或静态生成能力
- 应用主要是前端导向，后端逻辑相对简单
- 希望利用文件路由简化开发
- 需要快速部署到 Vercel 等平台

**NestJS**：

1. **架构灵感来自 Angular**：采用模块化、依赖注入、装饰器、面向切面编程
2. **强类型 TypeScript 支持**：几乎强制要求使用 TypeScript
3. **模块化设计**：通过 `@Module` 装饰器组织代码
4. **依赖注入 (DI)**：核心机制，提高可测试性和可维护性
5. **丰富的生态系统**：
   - **ORM 集成**：TypeORM、Sequelize、Prisma、Mongoose
   - **WebSockets**：`@nestjs/websockets`
   - **GraphQL**：`@nestjs/graphql`
   - **微服务**：内置支持多种传输层
   - **认证授权**：Passport.js 集成 (`@nestjs/passport`)
   - **任务调度**：`@nestjs/schedule`
   - **配置管理**：`@nestjs/config`
6. **可测试性强**：依赖注入使单元测试和服务模拟非常容易

**何时选择 NestJS？**

- 需要构建复杂、高可维护性的后端服务
- 需要数据库集成、认证、消息队列等企业级功能
- 计划构建微服务架构
- 团队熟悉 Angular 或喜欢 TypeScript 的强类型
- 需要高度可测试的后端代码

#### 最终选择

实际上，一种可行的方案是将两者结合：Next.js作为前端层和BFF（Backend For Frontend），NestJS作为核心后端服务：

1. **Next.js 作为前端层和 BFF(Backend For Frontend)**
   - 处理所有页面渲染 (SSR/SSG/CSR)
   - 处理简单的、与前端紧密相关的 API 请求 (通过 API Routes)
   - 代理或转发需要复杂业务逻辑的请求到 NestJS 后端
   - 管理路由、布局、UI 组件、状态
2. **NestJS 作为核心后端服务**
   - 提供主要的 RESTful API 或 GraphQL 端点
   - 处理核心业务逻辑、复杂的计算和数据处理
   - 与数据库、缓存、消息队列、外部服务交互
   - 实现用户认证、授权、支付集成等安全关键功能
   - 构建微服务

***然而目前看来，这个项目还是相对小型的，后端的功能也还是简单的，所以先只使用Next.js即可，等到需要NestJS的时候再进行引入。***

### 数据库

**SQLite**：

1. 项目保持小型化（用户量 < 1000）
2. 不需要高并发写入（如多人同时编辑博客）
3. 希望零配置部署（Vercel原生支持）
4. 开发环境简单（无需安装数据库服务）

**PostgreSQL**：

1. 预计博客会积累大量内容（>1000篇文章）
2. 需要高级功能（如标签系统、全文搜索）
3. 未来可能添加用户评论/互动功能
4. 需要数据备份/点恢复等企业级功能

#### 最终选择

先使用SQLite。

### 项目管理

由于要新增一个服务端，实际上有两种方案，单个项目使用Monorepo结构，或者是分为两个项目。

| **特性**     | Monorepo          | 多仓库             |
| :----------- | :---------------- | :----------------- |
| **代码共享** | ⭐⭐⭐ 直接引用      | ⭐⭐ 需发布包/子模块 |
| **新人上手** | ⭐⭐⭐ 单仓库克隆    | ⭐⭐ 多仓库配置      |
| **构建效率** | ⭐⭐ 需统一工具     | ⭐⭐⭐ 独立构建       |
| **权限控制** | ⭐ 粒度粗          | ⭐⭐⭐ 仓库级精细控制 |
| **独立部署** | ⭐ 需协调          | ⭐⭐⭐ 完全独立       |
| **适合场景** | 小团队/全栈工程师 | 中大团队/专业分工  |

#### 最终选择

使用Monorepo结构。





# 设计思路（before 25.03.12）

## 功能

这可能会是一个在之后会增加新模块的项目。目前的想法是个人博客模块和待办事项模块。

### 个人博客模块

能读取本地的MD文件，在网页上进行展示并进行编辑，最后应该保存到同样的位置，也可以选择另存到别的地方。

也可以直接创建MD文件。

需要有一个虚拟的目录结构，类似于文件夹，每一个文件还会有自己在本地存储中的实际地址。

这样的话，随之而来的就是对于文件以及文件夹的移动、删除、查询功能。

该项目并不会支持对于本地文件的移动，它更像一个管理系统，便于没有存放在一起、却有相同分类的文件可以在同一个文件夹中。

那么如果本地文件产生了移动，自然可能会出现之前链接绑定失效的情况，这里就需要有一个没找到文件的页面，去重新进行绑定。

#### 可选

- 让文件夹和文件的移动成为可拖动的。

- 类似于github的活动图

  ![image-20250211172105411](./pic/image-20250211172105411.png)

### 待办事项模块

这个则是会有一个待办事项的列表，其中存放着多个待办事项。

需要注意的是，待办事项会有时限，则它们会有已到期、即将到期、未完成、完成的状态。这个项目会存在一个首页，其中会显示有哪些待办事项即将到期，有哪些待办事项未完成。同时，这个项目会存在有顶部导航栏，也会显示有多少即将到期、多少未完成。

当然，会有一个统计页，其中会有一些相关的详细信息。

还有总的待办事项展示页面以及不同状态的待办事项列表展示页面。

#### 可选

- 在新产生即将到期的待办事项时，产生一个弹窗，其中有此待办事项以及其它即将到期的待办事项。（完成）

### 在线运行代码模块（可选）

可以通过切换语言以执行不同的代码。

### 杂项模块（可选）

- 更换背景，可以用图片作为背景，进行设置，如透明度。

### AI模块（可选）

引入对话式的AI

## 页面

首先，每个页面都会存在一个header，在下面不再重复。

这个header应该有一个项目名，点击后进行跳转到首页。还要有对于不同模块的页面的导航。以及对于due和expired待办事项

### 首页 /

**上下布局**

header

轮播图

分成待办事项和个人博客

待办事项处要显示有多少个即将到期的todo和多少个未完成的todo。

两者都需要一些标语。

### 待办事项统计页面 /todo/statistics

**上下布局**

在这里展示出总、已完成、未完成、即将到期、已到期的todo数量，并且可以通过点击去进入到对应展示页面。

### 总待办事项展示页面 /todo/list/all

### 已完成待办事项展示页面 /todo/list/finished

### 未完成待办事项展示页面 /todo/list/unfinished

### 即将到期待办事项展示页面 /todo/list/due

### 已到期待办事项展示页面 /todo/list/expired

**上下布局**

实际上它们都是使用了同一个复用的组件，列表组件。

这个组件中应该包含一个卡片：

header：标题+搜索框

content：对应的待办事项列表

footer：pagination

### 博客目录页面 /blog/directory

**上下布局**

在此处展示虚拟的目录结构，可以通过点击进行展开和折叠。

也可以通过搜索找到指定的文件和文件夹。

同时，这个组件应该被复用到博客的详情页中。

需要包含对于目录结构的操作。

### 博客详情页面 /blog/detail/:id

**上左下布局**

这里应该是left + content的结构。

左侧会是一个可伸缩的导航栏，用于展示虚拟目录结构。

右侧是博客的详情。

在content的上部，可以通过一个切换的按钮切换博客是编辑还是查看模式。

（以上是项目开始时的想法）

首先问是否要将本地内容同步到系统中，系统中的版本最后修改日期是。。。

之后就是常规的编辑和查看

然后就是可以通过按钮将内容保存到本地

#### 编辑模式

...

#### 查看模式

...

还需要有一个组件来表示没有找到对应的文件。

## redux

### features/todolist/todolistSlice

#### 数据

`Todo[]`

```ts
interface Todo
{
	state: boolean,
    content: string,
    expiration: number, // 时间戳？
};
```

#### 功能

编辑到期时间，编辑内容，切换完成状态，添加待办事项，删除待办事项。